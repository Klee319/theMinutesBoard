# Coding Prompt for Claude Code

## 0. Context  
- **必ず**最初に./ref/product及びディレクトリ内の資料（仕様書、設計書、タスク管理書）を読み取り、未実装の内容・ドメイン用語・エッジケース・非機能要件を把握する。  
- 上記資料に遵守し開発を行う。できない場合は開発を中断しユーザに質問する。
- 不明点があれば *コードを書く前に* 質問を列挙し、必要最小限の追加情報をリクエストする。  

---

## 1. Coding Standards
| 項目 | 指示 |
|------|------|
| スタイルガイド | 対象言語の公式ガイド（例: Python ➜ PEP 8）を遵守。 |
| 命名規則 | **説明的で一貫性** のある英語名。<br>・クラス: `PascalCase` / インターフェース: `IPascalCase`<br>・関数・変数: `snake_case`<br>**略語・当て字禁止** |
| 型ヒント | 可能な限り **静的型** を付与し、`mypy` / `pyright` でエラーゼロを保証。 |
| ジェネリクス | コレクション／ユーティリティ関数は **ジェネリクス** を活用し型安全に。 |
| フォーマッタ & Linter | `black` + `isort` + `ruff` (Python 例) を *pre-commit* に組込み、自動整形を必須化。 |

---

## 2. Readability (可読性)
1. **Why コメント**：処理内容ではなく “なぜ必要か” を記述。  
2. 関数長は **40 行以内**。複雑化したら抽出メソッド & 早期リターン。  
3. **マジックナンバー禁止**：意味のある値は定数または `Enum`。  
4. 公開 API には Google-style docstring。主要ロジック冒頭に「前提・制約」を明記。  
5. **Immutable**：共有・公開フィールドは `readonly` / `final`。メソッド引数も `Readonly[T]` で受け、副作用を排除。  
6. **過剰 DRY の回避**：コンテキストが異なるロジックは無理に共通化せず、将来の分岐を見越して冗長を許容する。  

---

## 3. Maintainability (保守性)
| 項目 | ベストプラクティス |
|------|--------------------|
| 設計原則 | **SOLID / DRY / KISS / YAGNI** を徹底。 |
| 継承 vs 合成 | 継承は `is-a` が厳密に成り立つ場合のみ。**Composition / Interface** を優先。 |
| レイヤリング | `domain → service → interface` 等で層分離し、依存逆転を採用。 |
| DI & Factory | 外部依存は **DI** で注入し、テスト容易性を高める。 |
| Cross-Cutting Concern | 認証・ロギング・トランザクション等は **Decorator / AOP** で注入し、ユースケース本体から分離。 |
| ハードコーディング禁止 | API キー等は環境変数 or `*.env` / `config.*` から読込む。 |
| レガシー API 隔離 | 旧 API や SDK は **Facade / Adapter / Factory** パターンで包み、呼び出し側をクリーンに保つ。 |
| Tech Debt 管理 | 技術的負債はタスク管理書に `TechDebt` タグ付きで登録し、償却計画を設定。 |

---

## 4. Security (セキュリティ)
- 既知の脆弱性（SQLi, XSS, CSRF, Directory Traversal など）を回避。  
- **入力値は必ずバリデーション & サニタイズ**。  
- 機密情報はログ出力しない。  
- 依存ライブラリは `dependabot` 等で最新を維持。  
- `bandit` / `npm audit` など静的解析ツールを CI に組込む。  

---

## 5. Performance (パフォーマンス)
| シナリオ | 指針 |
|----------|------|
| 大量データ処理 | アルゴリズム計算量とメモリフットプリントを評価し、必要ならストリーミング処理へ。 |
| ループ・I/O | ボトルネック箇所はプロファイラで計測し、データ構造を最適化。 |
| 並列処理 | CPU バウンド ➜ マルチプロセス / GPU、I/O バウンド ➜ async / マルチスレッドを検討。 |

---

## 6. Testing & Debugging
| カテゴリ | ベストプラクティス |
|-----------|--------------------|
| **単体テスト** | `pytest` / `Jest` 等を採用。正常系・異常系・境界値を網羅し、**カバレッジ 80 % 以上**。 |
| **TDD フロー** | **再現テスト → 実装 → リファクタ** を遵守。 |
| **静的解析** | `mypy`, `ruff`, `bandit` などを CI で必須。 |
| **ロギング** | 構造化ログ（JSON 可）。レベル分類 `DEBUG/INFO/WARNING/ERROR`。 |
| **エラーハンドリング** | 例外は握りつぶさず適切な層で捕捉し再スロー or 記録。ユーザ向けメッセージと内部ログを分離。 |

---

## 7. Commit & Pull Request
- feat(core): 新機能の概略
- fix(api): バグ修正 (#issue)
- refactor(test): テストリファクタ
- BREAKING CHANGE: 破壊的変更点
- 英語動詞 + 日本語補足推奨。
- PR テンプレで「目的 / 実装詳細 / テスト結果 / 影響範囲」を記入。

---

## 8. LLM-Friendly Generation Tips
- 先に構造を提示：ファイル構成・型定義・入出力契約 → 実装本体の順。
- 逐次コミット：大規模変更は小さく区切り、差分を段階的に提示。
- 自己チェック：生成後に pylint, pytest, mypy を AI 内部シミュレーション し、想定エラーを列挙。

---

## 9. Final Checklist（生成後に AI が自問）
- 設計書・仕様書と整合しているか
- 命名・型・フォーマットが規約通りか
- テストカバレッジ 80 %以上か
- エラーハンドリング・ログ・セキュリティが十分か
- パフォーマンスボトルネックはないか
- ずるは行っていないか（ハードコードや機能削除は禁止）
- 後回しになっている個所がないか（未実装、代替実装、簡易実装は禁止）
